#this section brings in the slicermorph landmarks and configures that analysis for use in R
##Unless noted this code is the same as that provided in the slicermorph tutorials here:https://github.com/SlicerMorph/Tutorials/blob/main/GPA_3/parser_and_sample_R_analysis.md
##This code is replicated so that all the same basic sanity checks are run to ensure consistent results.
nparser <- function(logfile=NULL, forceLPS=FALSE) {
cut = function(x) return(strsplit(x, "=")[[1]][2])
temp = unlist(lapply(X = readLines(logfile,w=F), FUN = cut))
log = list()
log$input.path = "./Data/LMs"
log$output.path = "./Data"
log$files = mixedsort(list.files(log$input.path))
log$format = temp[6]
log$no.LM = as.numeric(temp[7])
if (is.na(temp[8])) {
log$skipped = FALSE
} else {
log$skipped = TRUE
log$skipped.LM = unlist(strsplit(temp[8], ","))
}
if (is.na(temp[15])) {
log$semi = FALSE
} else {
log$semi = TRUE
log$semiLMs = unlist(strsplit(temp[15], ","))
}
if (as.logical(temp[9])) {
log$scale = TRUE
} else {
log$scale = FALSE
}
log$MeanShape = temp[10]
log$eigenvalues = temp[11]
log$eigenvectors = temp[12]
log$OutputData = temp[13]
log$pcScores = temp[14]
log$ID = gsub(log$format, "", fixed = T, log$files)
log$ID = gsub(".json", "", fixed = T, log$ID)
if (!log$skipped) {
log$LM = array(dim = c(log$no.LM, 3, length(log$files)),
dimnames = list(1:log$no.LM, c("x", "y", "z"), log$ID))
if (log$format == ".fcsv") {
for (i in 1:length(log$files)) log$LM[, , i] = read.markups.fcsv(paste(log$input.path,
log$files[i], sep = "/"), forceLPS)
} else { for (i in 1:length(log$files)) log$LM[, , i] = read.markups.json(paste(log$input.path,
log$files[i], sep = "/"))
}
} else {
log$LM = array(dim = c(log$no.LM - length(log$skipped.LM),
3, length(log$files)), dimnames = list((1:log$no.LM)[-as.numeric(log$skipped.LM)],
c("x", "y", "z"), log$ID))
if (log$format == ".fcsv") {
for (i in 1:length(log$files)) log$LM[, , i] = read.markups.fcsv(paste(log$input.path,
log$files[i], sep = "/"), forceLPS)[-c(as.numeric(log$skipped.LM)), ]
} else { for (i in 1:length(log$files)) log$LM[, , i] = read.markups.json(paste(log$input.path,
log$files[i], sep = "/"))[-c(as.numeric(log$skipped.LM)), ]
}
}
return(log)
}
library(ggplot2)
library(geomorph)
library(SlicerMorphR)
library(tidyverse)
library(gtools)
#Set a reproducibility seed
set.seed(2145)
#Navigate to the Slicermorph log file "Analysis.txt"
#This code parses he slicermorph GPA output into R readable data
SM.log.file <- file.choose()
SM.log <- nparser(SM.log.file, forceLPS = TRUE)
SM.output <- read.csv(file = paste(SM.log$output.path,
SM.log$OutputData,
sep = "/"))
#Navigate to the Slicermorph log file "Analysis.txt"
#This code parses he slicermorph GPA output into R readable data
SM.log.file <- file("./External_code/Data/analysis.log")
file.choose()
#Navigate to the Slicermorph log file "Analysis.txt"
#This code parses he slicermorph GPA output into R readable data
SM.log.file <- file.choose()
#Navigate to the Slicermorph log file "Analysis.txt"
#This code parses he slicermorph GPA output into R readable data
SM.log.file <- ".\Data\analysis.log"
SM.log <- nparser(SM.log.file, forceLPS = TRUE)
#Set a reproducibility seed
set.seed(2145)
#this section brings in the slicermorph landmarks and configures that analysis for use in R
##Unless noted this code is the same as that provided in the slicermorph tutorials here:https://github.com/SlicerMorph/Tutorials/blob/main/GPA_3/parser_and_sample_R_analysis.md
##This code is replicated so that all the same basic sanity checks are run to ensure consistent results.
nparser <- function(logfile=NULL, forceLPS=FALSE) {
cut = function(x) return(strsplit(x, "=")[[1]][2])
temp = unlist(lapply(X = readLines(logfile,w=F), FUN = cut))
log = list()
log$input.path = "./Data/LMs"
log$output.path = "./Data"
log$files = mixedsort(list.files(log$input.path))
log$format = temp[6]
log$no.LM = as.numeric(temp[7])
if (is.na(temp[8])) {
log$skipped = FALSE
} else {
log$skipped = TRUE
log$skipped.LM = unlist(strsplit(temp[8], ","))
}
if (is.na(temp[15])) {
log$semi = FALSE
} else {
log$semi = TRUE
log$semiLMs = unlist(strsplit(temp[15], ","))
}
if (as.logical(temp[9])) {
log$scale = TRUE
} else {
log$scale = FALSE
}
log$MeanShape = temp[10]
log$eigenvalues = temp[11]
log$eigenvectors = temp[12]
log$OutputData = temp[13]
log$pcScores = temp[14]
log$ID = gsub(log$format, "", fixed = T, log$files)
log$ID = gsub(".json", "", fixed = T, log$ID)
if (!log$skipped) {
log$LM = array(dim = c(log$no.LM, 3, length(log$files)),
dimnames = list(1:log$no.LM, c("x", "y", "z"), log$ID))
if (log$format == ".fcsv") {
for (i in 1:length(log$files)) log$LM[, , i] = read.markups.fcsv(paste(log$input.path,
log$files[i], sep = "/"), forceLPS)
} else { for (i in 1:length(log$files)) log$LM[, , i] = read.markups.json(paste(log$input.path,
log$files[i], sep = "/"))
}
} else {
log$LM = array(dim = c(log$no.LM - length(log$skipped.LM),
3, length(log$files)), dimnames = list((1:log$no.LM)[-as.numeric(log$skipped.LM)],
c("x", "y", "z"), log$ID))
if (log$format == ".fcsv") {
for (i in 1:length(log$files)) log$LM[, , i] = read.markups.fcsv(paste(log$input.path,
log$files[i], sep = "/"), forceLPS)[-c(as.numeric(log$skipped.LM)), ]
} else { for (i in 1:length(log$files)) log$LM[, , i] = read.markups.json(paste(log$input.path,
log$files[i], sep = "/"))[-c(as.numeric(log$skipped.LM)), ]
}
}
return(log)
}
#Navigate to the Slicermorph log file "Analysis.txt"
#This code parses he slicermorph GPA output into R readable data
SM.log.file <- ".\Data\analysis.log"
#Navigate to the Slicermorph log file "Analysis.txt"
#This code parses he slicermorph GPA output into R readable data
SM.log.file <- ".\\Data\\analysis.log"
SM.log <- nparser(SM.log.file, forceLPS = TRUE)
SM.output <- read.csv(file = paste(SM.log$output.path,
SM.log$OutputData,
sep = "/"))
